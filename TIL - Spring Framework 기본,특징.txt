1.오늘 학습 내용 중 새롭게 배운 내용은 무엇인가요?

Framework 이란?
Framework와 Library의 차이
Spring Framework 이란?
Spring Framework을 배워야하는 이유
POJO
POJO와 Spring Framework의 관계
IOC
DI
AOP와 AOP가 필요한 이유
PSA
보너스. 객체지향설계 원칙

2.오늘 새롭게 학습한 내용을 다른 사람에게 설명할 수 있나요?

Framework 이란?
기본적으로 프로그래밍을 하기 위한 어떠한 틀이나 구조
장점: 1.효율적으로 코드를 작성할 수 있음.-> 개발자가 애플리케이션의 핵심 로직을 개발하는 것에 집중 가능 2. 정해진 규약이 있어 애플리케이션을 효율적으로 관리 -> 유지보수 쉬움. 코드 재사용 용이, 기능의 확장 또한 쉬움.
단점: 1. 내가 사용하고자 하는 Framework에 대한 학습 필요. 2. 자유롭고 유연한 개발은 어려움. -> 구조가 정해져 있기 때문에.

Framework와 Library의 차이
Library는 애플리케이션을 개발하는데 사용되는 일련의 데이터 및 프로그래밍 코드.
Library는 애플리케이션을 개발할 때 필요한 기능을 미리 구현해놓은 집합체
둘 다 누군가가 만들어 놓은것을 가져다 쓰는 거지만, Framework는 한번 사용해서 구현하면 바꾸기가 어렵고 Library는 쉽게 교체 가능. 필요한 기능만 선택적 사용 가능.
애플리케이션에 대한 제어권의 차이
개발자가 짜 놓은 코드내에서 필요한 기능이 있으면 해당 라이브러리를 호출해서 사용하는 것이 바로 Library.
애플리케이션 흐름의 주도권이 개발자에게 있음-> Library, 애플리케이션 흐름의 주도권이 개발자가 아닌 Framework에 있음->Framework

Spring Framework 이란?
POJO(Plan Old Java Object)기반의 구성
DI(Dependency injection) 지원
AOP(Aspect Oriented Programing, 관점지향 프로그래밍)지원
Java 언어를 사용함으로써 얻는 장점
Spring Framework을 학습하면? 1. 객체지향 설계 원칙에 잘 맞는 재사용과 확장이 간으한 애플리케이션 개발 스킬 향상, 2. 보다 나은 성능과 서비스의 안전성이 필요한 복잡한 기업용 엔터프라이즈 시스템 구축 가능

Spring Framework을 배워야하는 이유
Spring Framework이 도입되기 전에는 JSP나 Serblet 기술을 사용한 Model1, Model2 아키텍처를 기반으로 한 Java 웹 애플리케이션 제작 -> 설계하기 오지게 힘들었음.
Spring MVC방식이 도입됨으로써 Java 웹 애플리케이션의 제작 방식이 획기적으로 변함.
Spring MVC 설정의 복잡함과 어려움을 극복하기 위한 Spring Boot 탄생

POJO
Plain Old Java Object
POJO란 순수한 Java 객체를 의미
Java나 Java의 스펙(사양)에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 됨. (상속하거나 종속 되면 나중에 수정시 일일이 전부다 바꾸어야 함. 상속을 받아버리면 다중 상속 불가능.)
특정 환경에 종속적이지 않아야 함. 내가 쓰던 프레임이 바뀌었을 경우 코드를 전부 뜯어고쳐야 한다면 객체지향이 아님.
POJO 프로그래밍은 특정 환경이나 기술에 종속적이지 않으면 재사용 가능, 확장 가능한 유연한 코드 작성 가능, 저수준 레벨의 기술과 환경에 종속적인 코드를 애플리케이션 코드에 제거함으로써 코드가 깔끔, 디버깅도 상대적으로 쉬움, 특정 기술이나 환경에 종속적이지 않기 때문에 테스트 역시 단순해짐, 가장 중요한 이유는 객체지향적인 설계를 제한없이 적용할 수 있음
Spring은 POJO 프로그래밍을 지향하는 Framework
애플리케이션 프로그래밍 코드를 작성할 때 항상 내가 작성한 코드가 객체지향스러운가에 대한 고민을 하는 습관을 가져야 함.
POJO와 Spring Framework의 관계
POJO 프로그래밍을 효과적으로 적용하기 위해서는 특정 기술에 대한 지식보다는 JDK의 API에 대한 지식과 객체지향적인 사고방식과 설계를 위한 훈련이 우선시 되어야 함.
Spring Framework은 POJO 프로그래밍을 지향하기 위해 IOC/DI, AOP, PSA라는 기술을 제공함.

IOC
Inversion of control -> 애플리케이션 흐름의 주도권이 뒤바뀐 것.
main()메서드가 없고 서블릿 컨테이너가 서블릿을 제어함. 서블릿 컨테이너 내에 컨테이너 로직이 서블릿을 직접 실행시켜 주기 때문에 main()가 필요 없음.

DI
Dependency Injection(의존성 주입) 음.. 부품 조립?
생성자를 통해서 어떤 클래스의 객체를 전달 받는 것을 의존성 주입이라고 함. 생성자의 파라미터로 객체를 전달하는 것을 외부에서 객체를 주입한다라고 표현.
느슨한 결합이 좋고 그것은 인터페이스를 활용하면 됨.
애플리케이션 흐름의 주도권이 사용자에게 있지 않고, Framework이나 서블릿 컨테이너 등 외부에 있는 것 즉, 흐름의 주도권이 뒤바뀐 것을 IOC(Inversion of Control)라고 함.
DI(Dependency Injection)는 IOC개념을 조금 구체화 시킨 것으로 객체 간의 관계를 느슨하게 해줌.
클래스 내부에서 다른 클래스의 객체를 생성하게 되면 두 클래스 간에 의존관계가 성립함.
클래스 내부에서 new를 사용해 참조할 클래스의 객체를 직접 생성하지 않고, 생성자 등을 통해 외부에서 다른 클래스의 객체를 전달받고 있다면 의존성 주입이 이루어지고 있는 것임.
new 키워드를 사용하여 객체를 생성할 때, 클래스 간에 강하게 결합되어 있음.
어떤 클래스가 인터페이스 같이 일반화 된 구성요소에 의존하고 있을 때, 클래스들 간에 느슨하게 결합되어 있다고 함.
객체들 간의 느슨한 결합은 요구 사항의 변경에 유연하게 대처할 수 있도록 해줌.
의존성 주입(DI)은 클래스들 간의 강한 결합을 느슨한 결합으로 만들어 줌.
Spring에서는 애플리케이션 코드에서 이루어지는 의존성 주입을 Spring이 대신 해줌.

AOP와 AOP가 필요한 이유
Aspect Oriented Programming 관심지향 프로그래밍
공통관심사항(Cross-cutting concern): 애플리케이션 전반에 걸쳐 공통적으로 사용되는 기능, 부가적인 관심사항으로 표현하기도 함.
-핵심 관심사항: 비지니스 로직, 애플리케이션의 주목적 달성을 위한 핵심 로직
애플리케이션의 핵심 업무 로직에서 로깅이나 보안, 트랜잭션 같은 공통 기능 로직들을 분리하는 것.
AOP가 필요한 이유는 코드의 간결성을 유지하고 객체 지향 설계 원칙에 맞는 코드를 구현하고 코드의 재사용을 높이려고.
AOP에서 의미하는 Aspect는 애플리케이션의 공통 관심사 의미
공통 관심사는 비지니스 로직을 제외한 애플리케이션 전반에 걸쳐서 사용되는 공통 기능

PSA
portable service abstraction 일관된 서비스 추상화
일관된 방식으로 해당 서비스의 기능을 사용할 수 있음.
애플리케이션의 특정 서비스를 이용할 때, 서비스의 기능을 접근하는 방식 자체를 일관되게 유지하면서 기술 자체를 유연하게 사용할 수 있도록 하는 것을 PSA라고 함.
PSA가 필요한 이유: 어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지함으로써 애플리케이션에서 사용하는 기술이 변경되더라도 최소한의 변경만으로 변경된 요구사항을 반영하기 위함. 애플리케이션의 요구 사항 변경에 유연하게 대처할 수 있음.
객체지향 프로그래밍 세계에서 본질적인 특성만을 추출해서 일반화하는 것을 추상화라고 함.

보너스. 객체지향설계 원칙
높은 응집력: 비슷한 일을 하는 기능, 하나의 책임에 포함되는 기능들이 잘 뭉쳐 있으면 응집력 높음. 하나의 기능을 변경하는데 여기저기 변경해야하면 응집력 낮음.
낮은 결합도: 클래스 간의 의존성이 낮다면 낮은 결합도, 하나의 클래스를 수정하는데 의존하는 다른 클래스 모두 수정해야 한다면 결합도 높음.
SOLID 원칙 (SRP, OCP, LSP, ISP, DIP)
SRP(Single Responsibility Principle, 단일 책임의 원칙): 클래스가 제공하는 기능들은 하나의 책임을 수행하는데 집중해야 함.
OCP(Open Close principle, 개방폐쇄의 원칙): 확장에는 열려있고 변경에는 닫혀 있어야 함. 변하는 것과 변하지 않는 것을 잘 구분. 변하지 않는 것은 변하는 것의 구현에 의존하지 않고 인터페이스를 통해 느슨하게 의존.
LSP(The Liskov Substitution Principle, 리스코브 치환의 원칙): subclass의 객체는 superclass의 참조 변수에 대입해서 superclass의 역할을 수행하는데 문제가 없어야 함. OCP 원칙의 기반.
ISP(Interface Segregation Principle, 인터페이스 분리의 원칙): 인터페이스의 단일 책임을 위한 원칙. 일반적인 하나의 인터페이스를 조금 더 구체적인 인터페이스로 쪼개는 것이 낫다.
DIP(Dependency Inversion Principle, 의존성 역전의 원칙): 자주 변경되는 구체 클래스에 의존하지 않고, 추상화(일반화) 된 클래스에 의존하는 것. 구체 클래스가 추상 클래스에 의존하므로 의존 관계가 역전된 형태,

3.오늘 학습한 내용 중 아직 이해되지 않은 불확실한 내용은 무엇인가요?
기본개념인데도 아직 정확히 이해가 되지는 않는것 같음.

4.이해되지 않은, 불확실한 내용을 보완하기 위해서 나는 무엇을 할 수 있을까요?
이해가 안되더라도 익숙해질 수 있도록 관련 유투브 강의를 한번씩 보도록 하겠음.

5.나의 오늘 학습 만족도는 몇점인가요?
70점. 절반 이상은 갔다고 생각함. 사전에 스프링 관련 유투브 강의를 조금 본것이 도움이 될랑말랑 했음. 나쁘지는 않았음.